{{- if or (and .Values.graphql.jwtSecret.enabled (not .Values.graphql.jwtSecret.existingSecret)) (and .Values.postgresql.enabled (not .Values.postgresql.auth.existingSecret)) }}
---
apiVersion: batch/v1
kind: Job
metadata:
  name: {{ include "flyball-planner.fullname" . }}-secret-generator
  labels:
    {{- include "flyball-planner.labels" . | nindent 4 }}
    app.kubernetes.io/component: secret-generator
  annotations:
    "helm.sh/hook": pre-install,pre-upgrade,post-delete
    "helm.sh/hook-weight": "-5"
    "helm.sh/hook-delete-policy": before-hook-creation,hook-succeeded
spec:
  template:
    metadata:
      labels:
        {{- include "flyball-planner.selectorLabels" . | nindent 8 }}
        app.kubernetes.io/component: jwt-secret-generator
    spec:
      serviceAccountName: {{ include "flyball-planner.fullname" . }}-secret-generator
      restartPolicy: Never
      containers:
      - name: secret-generator
        image: bitnami/kubectl:latest
        command:
        - /bin/bash
        - -c
        - |
          set -e

          NAMESPACE="{{ .Release.Namespace }}"
          HOOK_TYPE="{{ .Release.Hook }}"

          echo "Secret Management Job - Hook Type: $HOOK_TYPE"
          echo "Namespace: $NAMESPACE"

          {{- if and .Values.graphql.jwtSecret.enabled (not .Values.graphql.jwtSecret.existingSecret) }}
          JWT_SECRET_NAME="{{ include "flyball-planner.fullname" . }}-jwt-secret"
          {{- end }}
          {{- if and .Values.postgresql.enabled (not .Values.postgresql.auth.existingSecret) }}
          POSTGRES_SECRET_NAME="{{ include "flyball-planner.fullname" . }}-postgresql-secret"
          {{- end }}

          if [ "$HOOK_TYPE" = "post-delete" ]; then
            echo "Post-delete hook: Cleaning up secrets..."

            {{- if and .Values.graphql.jwtSecret.enabled (not .Values.graphql.jwtSecret.existingSecret) }}
            if kubectl get secret "$JWT_SECRET_NAME" -n "$NAMESPACE" >/dev/null 2>&1; then
              echo "JWT secret '$JWT_SECRET_NAME' exists, deleting..."
              kubectl delete secret "$JWT_SECRET_NAME" -n "$NAMESPACE"
              echo "JWT secret '$JWT_SECRET_NAME' deleted successfully."
            else
              echo "JWT secret '$JWT_SECRET_NAME' does not exist, nothing to delete."
            fi
            {{- end }}

            {{- if and .Values.postgresql.enabled (not .Values.postgresql.auth.existingSecret) }}
            if kubectl get secret "$POSTGRES_SECRET_NAME" -n "$NAMESPACE" >/dev/null 2>&1; then
              echo "PostgreSQL secret '$POSTGRES_SECRET_NAME' exists, deleting..."
              kubectl delete secret "$POSTGRES_SECRET_NAME" -n "$NAMESPACE"
              echo "PostgreSQL secret '$POSTGRES_SECRET_NAME' deleted successfully."
            else
              echo "PostgreSQL secret '$POSTGRES_SECRET_NAME' does not exist, nothing to delete."
            fi
            {{- end }}

            echo "Secret cleanup completed successfully."
            exit 0
          fi

          {{- if and .Values.graphql.jwtSecret.enabled (not .Values.graphql.jwtSecret.existingSecret) }}
          echo "Checking if JWT secret '$JWT_SECRET_NAME' already exists..."

          if kubectl get secret "$JWT_SECRET_NAME" -n "$NAMESPACE" >/dev/null 2>&1; then
            echo "JWT secret '$JWT_SECRET_NAME' already exists, skipping generation."
          else
            echo "JWT secret '$JWT_SECRET_NAME' does not exist, generating new secret..."

            JWT_SECRET=$(openssl rand -base64 48 | tr -d "=+/" | cut -c1-64)

            kubectl create secret generic "$JWT_SECRET_NAME" \
              --from-literal=jwt-secret="$JWT_SECRET" \
              -n "$NAMESPACE" \
              --dry-run=client -o yaml | kubectl apply -f -

            echo "JWT secret '$JWT_SECRET_NAME' created successfully."
          fi
          {{- end }}

          {{- if and .Values.postgresql.enabled (not .Values.postgresql.auth.existingSecret) }}
          echo "Checking if PostgreSQL secret '$POSTGRES_SECRET_NAME' already exists..."

          if kubectl get secret "$POSTGRES_SECRET_NAME" -n "$NAMESPACE" >/dev/null 2>&1; then
            echo "PostgreSQL secret '$POSTGRES_SECRET_NAME' already exists, skipping generation."
          else
            echo "PostgreSQL secret '$POSTGRES_SECRET_NAME' does not exist, generating new secret..."

            POSTGRES_PASSWORD=$(openssl rand -base64 32 | tr -d "=+/" | cut -c1-32)

            kubectl create secret generic "$POSTGRES_SECRET_NAME" \
              --from-literal=password="$POSTGRES_PASSWORD" \
              -n "$NAMESPACE" \
              --dry-run=client -o yaml | kubectl apply -f -

            echo "PostgreSQL secret '$POSTGRES_SECRET_NAME' created successfully."
          fi
          {{- end }}

          echo "Secret generation completed successfully."
        resources:
          limits:
            memory: "64Mi"
            cpu: "100m"
          requests:
            memory: "32Mi"
            cpu: "50m"
      securityContext:
        runAsNonRoot: true
        runAsUser: 1001
        fsGroup: 1001
{{- end }}
